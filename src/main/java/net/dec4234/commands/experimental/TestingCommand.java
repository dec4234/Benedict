package net.dec4234.commands.experimental;

import net.dec4234.database.collections.UserManagement;
import net.dec4234.framework.commands.SlashCommand;
import net.dec4234.framework.misc.CachedValue;
import net.dv8tion.jda.api.entities.Member;
import net.dv8tion.jda.api.entities.MessageChannel;
import net.dv8tion.jda.api.events.interaction.SlashCommandEvent;
import net.dv8tion.jda.api.interactions.commands.OptionType;
import net.dv8tion.jda.api.interactions.commands.build.OptionData;

import java.util.List;

public class TestingCommand extends SlashCommand {

	public TestingCommand() {
		super("test2", "A test command", new OptionData(OptionType.STRING, "optional", "optional").setRequired(false));

		// CachedValue.getGuild().deleteCommandById("849280330624008192").queue();
	}

	@Override
	public void onCommand(SlashCommandEvent event, MessageChannel messageChannel, Member member) {
		if(!event.isAcknowledged()) {
			event.reply("Reply").queue();

			// System.out.println(new UserManagement().getMembersAtTime(System.currentTimeMillis()));

			List<Member> members = CachedValue.getGuild().getMembersWithRoles(CachedValue.getMemberRole());
			UserManagement userManagement = new UserManagement();

			for(Member member1 : members) {
				if(userManagement.getClanUsers(member1.getEffectiveName()).size() == 0) {
					System.out.println(member1.getEffectiveName() + " " + member1.getId());
				}
			}

		}
	}

	/*
	@Override
	public void onSlashCommand(SlashCommandEvent event) {
		if(event.getGuild() == null) {
			return;
		}
		Member sender = event.getMember();

		switch (event.getName()) {
			case "test":
				event.reply("Yo")
					 .addActionRow(
							 Button.success(sender.getId() + ":prune:", "First"),
							 Button.secondary(sender.getId() + ":delete:", "Second")
					 ).queue();
				break;
		}
	}

	@Override
	public void onButtonClick(ButtonClickEvent event) {
		String[] id = event.getComponentId().split(":"); // this is the custom id we specified in our button
		String authorId = id[0];
		String type = id[1];
		// When storing state like this is it is highly recommended to do some kind of verification that it was generated by you, for instance a signature or local cache
		if (!authorId.equals(event.getUser().getId()))
			return;
		MessageChannel channel = event.getChannel();
		switch (type)
		{
			case "prune":
				channel.editMessageById(event.getMessageId(), "Yo").queue();

				break;
			case "delete":
				event.getHook().deleteOriginal().queue();
				break;
		}
		if(!event.isAcknowledged()) {
			event.deferEdit().queue();
		}
	}
	 */
}
